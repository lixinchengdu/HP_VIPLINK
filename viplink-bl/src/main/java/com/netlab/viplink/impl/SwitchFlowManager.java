//  (c) Copyright 2013 Hewlett-Packard Development Company, L.P.
//  Autogenerated
package com.netlab.viplink.impl;

import java.util.UUID;

import static com.hp.util.StringUtils.isEmpty;

import com.netlab.viplink.model.SwitchFlow;
import com.netlab.viplink.api.SwitchFlowService;

import com.hp.api.CreateException;
import com.hp.api.NotFoundException;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;
import java.util.Collections;
import java.util.Set;
import java.util.UUID;

import com.hp.api.Id;
import com.hp.of.ctl.ControllerService;
import com.hp.of.ctl.FlowClassRegistrator;
import com.hp.of.ctl.MessageEvent;
import com.hp.of.ctl.MessageListener;
import com.hp.of.ctl.OpenflowEventType;
import com.hp.of.ctl.QueueEvent;
import com.hp.of.ctl.pkt.MessageContext;
import com.hp.of.ctl.pkt.PacketListenerRole;
import com.hp.of.ctl.pkt.PacketOut;
import com.hp.of.ctl.pkt.SequencedPacketAdapter;
import com.hp.of.ctl.pkt.SequencedPacketListener;
import com.hp.of.ctl.prio.FlowClass;
import com.hp.of.lib.OpenflowException;
import com.hp.of.lib.ProtocolVersion;
import com.hp.of.lib.dt.DataPathId;
import com.hp.of.lib.dt.DataPathInfo;
import com.hp.of.lib.dt.TableId;
import com.hp.of.lib.instr.ActOutput;
import com.hp.of.lib.instr.ActionType;
import com.hp.of.lib.instr.InstrMutableAction;
import com.hp.of.lib.instr.Instruction;
import com.hp.of.lib.instr.InstructionType;
import com.hp.of.lib.match.Match;
import com.hp.of.lib.match.MatchFactory;
import com.hp.of.lib.match.MutableMatch;
import com.hp.of.lib.match.OxmBasicFieldType;
import com.hp.of.lib.msg.FlowModCommand;
import com.hp.of.lib.msg.MessageFactory;
import com.hp.of.lib.msg.MessageFuture;
import com.hp.of.lib.msg.MessageType;
import com.hp.of.lib.msg.OfmFlowMod;
import com.hp.of.lib.msg.OfmMutableFlowMod;
import com.hp.of.lib.msg.OpenflowMessage;
import com.hp.of.lib.msg.Port;
import com.hp.sdn.adm.auditlog.AuditLogService;
import com.hp.util.ip.BigPortNumber;
import com.hp.util.ip.EthernetType;
import com.hp.util.ip.IpAddress;
import com.hp.util.ip.IpProtocol;
import com.hp.util.ip.MacAddress;
import com.hp.util.ip.PortNumber;
import com.hp.util.ip.VlanId;
import com.hp.util.pkt.Ethernet;
import com.hp.util.pkt.Ip;
import com.hp.util.pkt.IpType;
import com.hp.util.pkt.ProtocolId;
import com.hp.util.pkt.Tcp;
import com.hp.util.pkt.Udp;

import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.apache.felix.scr.annotations.ReferencePolicy;
import org.apache.felix.scr.annotations.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.hp.of.lib.match.OxmBasicFieldType.*;
import static com.hp.of.lib.match.FieldFactory.createBasicField;
import static com.hp.of.lib.instr.ActionFactory.createAction;
import static com.hp.of.lib.instr.ActionFactory.createActionSetField;
import static com.hp.of.lib.instr.InstructionFactory.*;

import static com.hp.of.ctl.prio.FlowClass.ActionClass.*;
//import static com.hp.of.lib.match.OxmBasicFieldType.*;
import com.hp.of.ctl.FlowClassRegistrator;

/**
 * Sample SwitchFlow service implementation.
 */
@Component(metatype=true)
@Service
public class SwitchFlowManager extends SequencedPacketAdapter implements SwitchFlowService{
	
	@Reference(policy = ReferencePolicy.DYNAMIC,
	cardinality = ReferenceCardinality.MANDATORY_UNARY)
	private volatile ControllerService controller;
	
	@Reference(policy = ReferencePolicy.DYNAMIC,
	cardinality = ReferenceCardinality.MANDATORY_UNARY)
	private volatile AuditLogService auditLogService;
	
	//Set the packets of interest
	private static final Set<ProtocolId> INTEREST = EnumSet.of(ProtocolId.TCP, ProtocolId.UDP);
	
	//names for flowClasses
	private static final String PASSWORD = "netlab";
	private static final String VIP_PATH_TCPINITIAL_FWD = "com.netlab.app.vip.tcpinitialpath";
	private static final String VIP_PATH_UDPINITIAL_FWD = "com.netlab.app.vip.udpinitialpath";
	private static final String VIP_PATH_TCPREFINE_FWD = "com.netlab.app.vip.tcprefinepath";
	private static final String VIP_PATH_UDPREFINE_FWD = "com.netlab.app.vip.udprefinepath";
	private static final String VIP_DESC_TCPINITIAL = "Tcp initial path forwarding flows";
	private static final String VIP_DESC_UDPINITIAL = "Udp initial path forwarding flows";
	private static final String VIP_DESC_TCPREFINE = "Tcp Refined path forwarding flows";
	private static final String VIP_DESC_UDPREFINE = "Udp Refined path forwarding flows";
	
	//Marker for failing to install/remove switchflow
	private static final String FLOWINSTALLFAIL = "Fail to install flow: {}";
	private static final String FLOWDELETEFAIL = "Fail to delete flow: {}";
	
	//Hard code to set the altitude 
	private static final int DR_ALTITUDE = 9999;
	
	//Define FlowClasses to install OpenFlow rules
	private FlowClass initialTcpFlowClass;
	private FlowClass initialUdpFlowClass;
	private FlowClass refinedTcpFlowClass;
	private FlowClass refinedUdpFlowClass;
	
	private static final int refinedPriority = 50000;
	
	//Get a class logger
	private Logger log = LoggerFactory.getLogger(getClass());
	
	@Activate
	public void activate(){
		//Register for Flow Classes
		initialTcpFlowClass =  new FlowClassRegistrator(VIP_PATH_TCPINITIAL_FWD, PASSWORD, VIP_DESC_TCPINITIAL)
		.fields(ETH_TYPE, IPV4_SRC, IPV4_DST, IP_PROTO, TCP_DST)
		.actions(FORWARD).actions(PROCESS).register(controller);
		
		initialUdpFlowClass = new FlowClassRegistrator(VIP_PATH_UDPINITIAL_FWD, PASSWORD, VIP_DESC_UDPINITIAL)
		.fields(ETH_TYPE, IPV4_SRC, IPV4_DST, IP_PROTO, UDP_DST)
		.actions(FORWARD).actions(PROCESS).register(controller);
		
		refinedTcpFlowClass = new FlowClassRegistrator(VIP_PATH_TCPREFINE_FWD, PASSWORD, VIP_DESC_TCPREFINE)
		.fields(ETH_TYPE, IPV4_SRC, IPV4_DST, IP_PROTO, TCP_SRC, TCP_DST)
		.actions(FORWARD).actions(PROCESS).register(controller);
		
		refinedUdpFlowClass = new FlowClassRegistrator(VIP_PATH_UDPREFINE_FWD, PASSWORD, VIP_DESC_UDPREFINE)
		.fields(ETH_TYPE, IPV4_SRC, IPV4_DST, IP_PROTO, UDP_SRC, UDP_DST)
		.actions(FORWARD).actions(PROCESS).register(controller);
		
		//Register for packet listener
		controller.addPacketListener(this, PacketListenerRole.DIRECTOR, DR_ALTITUDE, INTEREST);
	}
	
	@Deactivate
	public void deactivate(){
		
		//Unregister Flow Classes
		controller.unregisterFlowClass(initialTcpFlowClass, PASSWORD);
		controller.unregisterFlowClass(initialUdpFlowClass, PASSWORD);
		controller.unregisterFlowClass(refinedTcpFlowClass, PASSWORD);
		controller.unregisterFlowClass(refinedUdpFlowClass, PASSWORD);
		
		//Unregister packet listener
		controller.removePacketListener(this);
	}
	
    // Just for kicks in-memory store.
    private static final Map<Id<SwitchFlow, UUID>, SwitchFlow> store = 
        new HashMap<Id<SwitchFlow, UUID>, SwitchFlow>();
    
    //For fast cookie to rule lookup
    private static final Map< Long, Id<SwitchFlow, UUID>> cookie2id = 
    		new HashMap< Long, Id<SwitchFlow, UUID>> ();
    
    // For storing questionable SwitchFlows which show inconsistent views between the controller and switches
    //private static final Map<Id<SwitchFlow, UUID>, SwitchFlow> questionable = 
    //		new HashMap<Id<SwitchFlow, UUID>, SwitchFlow>();

    @Override
    public Collection<SwitchFlow> getAll() {
        synchronized (store) {
            return Collections.unmodifiableCollection(store.values());
        }
    }
    
    /**
     * Check whether the arguments contain null
     * @param name
     * @param dpid
     * @param srcip
     * @param dstip
     * @param protl
     * @param dstport
     * @param outport
     * @throw CreateException if one or more of the arguments is null 
     */
    
    private void CheckNull(String name, DataPathId dpid, IpAddress srcip, IpAddress srcipmask, 
    		IpAddress dstip, IpAddress dstipmask,  
    		IpProtocol protl, PortNumber dstport, MacAddress insrcmac, MacAddress indstmac, 
    		MacAddress outsrcmac, MacAddress outdstmac,  
    		VlanId invlan, VlanId outvlan, BigPortNumber inport, BigPortNumber outport, 
    		Integer pushvlan){
    	Set<String> nullargs = new HashSet<String>();
    	if (name == null){
    		nullargs.add("flow name");
    	}
    	if (dpid == null){
    		nullargs.add("switch id");
    	}
    	if (srcip == null){
    		nullargs.add("source ip");
    	}
    	
    	if (srcipmask == null){
    		nullargs.add("source ip mask");
    	}
    	
    	if (dstip == null){
    		nullargs.add("destination ip");
    	}
    	
    	if (dstipmask == null){
    		nullargs.add("destination ip mask");
    	}
    	
    	if (protl == null){
    		nullargs.add("transportation protocol");
    	}
    	
    	if (dstport == null){
    		nullargs.add("destination transport number");
    	}
    	
    	if (insrcmac == null){
    		nullargs.add("input source mac address");
    	}
    	
    	if (indstmac == null){
    		nullargs.add("input destination mac address");
    	}
    	
    	if (outsrcmac == null){
    		nullargs.add("output source mac address");
    	}
    	
    	if (outdstmac == null){
    		nullargs.add("output destination mac address");
    	}
    	
    	if (invlan == null){
    		nullargs.add("input vlan");
    	}
    	
    	if (outvlan == null){
    		nullargs.add("output vlan");
    	}
    	
    	if (inport == null){
    		nullargs.add("input physical interface");
    	}
    	
    	if (outport == null){
    		nullargs.add("output physical interface");
    	}
    	
    	if (pushvlan == null){
    		nullargs.add("push vlan flag");
    	}
    	
    	if (!nullargs.isEmpty()){
    		String e = "These arguments are missing:";
    		for (String arg: nullargs){
    			e += arg;
    			e += ",";
    		}
    		throw new CreateException(e);
    	}
    }
    
    
    
    @Override
    public SwitchFlow create(String name, DataPathId dpid, IpAddress srcip, IpAddress srcipmask, 
    		IpAddress dstip, IpAddress dstipmask, 
			  IpProtocol protl, PortNumber dstport, MacAddress insrcmac, MacAddress indstmac, 
			  MacAddress outsrcmac, MacAddress outdstmac,
			  VlanId invlan, VlanId outvlan, BigPortNumber inport, BigPortNumber outport,
			  Integer pushvlan) throws OpenflowException, CreateException{
    	CheckNull(name, dpid, srcip, srcipmask, dstip, dstipmask, protl, dstport, insrcmac, indstmac, outsrcmac, 
    			outdstmac, invlan, outvlan, 
    			inport, outport, pushvlan);
    	if (!(protl.equals(IpProtocol.TCP)||protl.equals(IpProtocol.UDP)))
    		throw new CreateException("IP Protocol Field is neither TCP nor UDP");
    	
    	SwitchFlow s = new SwitchFlow(name, dpid, srcip, srcipmask, dstip, dstipmask, protl, 
    			dstport, insrcmac, indstmac, outsrcmac, outdstmac,  
    			invlan, outvlan, inport, outport, pushvlan.intValue());
    	synchronized (store){
    		if(isEmpty(s.name())){
    			throw new CreateException("SwitchFlow name undefined");
    		}
    		for (Id<SwitchFlow, UUID> flowId: store.keySet()){
    			if (store.get(flowId).name().equals(name))
    				throw new CreateException("SwitchFlow with name " + name + " already exists");
    			if (store.get(flowId).dpid().equals(dpid) && 
    					store.get(flowId).srcip().equals(srcip) &&
    					store.get(flowId).srcipmask().equals(srcipmask) &&
    					store.get(flowId).dstip().equals(dstip) && 
    					store.get(flowId).dstipmask().equals(dstipmask) &&
    					store.get(flowId).protl().equals(protl) &&
    					store.get(flowId).srcport().equals(PortNumber.valueOf(0)) &&
    					store.get(flowId).dstport().equals(dstport)
    					)
    				throw new CreateException("SwitchFlow with name " + name + "collide with unrefined flow");
    		}
    	}	
    	
    	install(s.getId(), s);
    	return s;
    }
	
    /**
     * Install a rule in the switch
     * @param s
     * @return indicator whether the installation succeeds. True indicates success, false indicates failure
     * @throws OpenflowException if fail to install a rule in the switch
     */
    private void installByFlowMod(SwitchFlow s) throws OpenflowException{
    
    	// Hard coded timeout 
    	long REQUEST_TIMEOUT_MS = 5000;
    	long then = System.currentTimeMillis();
    	
    	ProtocolVersion negotiatedProtocolVersion = controller.getDataPathInfo(s.dpid()).negotiated();
    	
    	OfmMutableFlowMod fm = (OfmMutableFlowMod)MessageFactory.create(negotiatedProtocolVersion, MessageType.FLOW_MOD,
    																	FlowModCommand.ADD);
    	if (s.protl().equals(IpProtocol.TCP)){
    		fm.cookie(initialTcpFlowClass.baseCookie()|s.hashCode()).priority(initialTcpFlowClass.priority()).match(createMatch(s));
    	}
    	if (s.protl().equals(IpProtocol.UDP)){
    		fm.cookie(initialUdpFlowClass.baseCookie()|s.hashCode()).priority(initialUdpFlowClass.priority()).match(createMatch(s));
    	}
    	
    	// For OpenFlow Version = 1.o
    	if (negotiatedProtocolVersion.equals(ProtocolVersion.V_1_0)){
    		//fm.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD, 
    		//		createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.VLAN_VID, s.outvlan());
    		fm.addAction(createAction(negotiatedProtocolVersion, ActionType.OUTPUT, Port.CONTROLLER, ActOutput.CONTROLLER_NO_BUFFER));
    	}
    	
		// For OpenFlow Version >= 1.1
    	if (negotiatedProtocolVersion.ge(ProtocolVersion.V_1_1)){
    		InstrMutableAction apply = createMutableInstruction(negotiatedProtocolVersion, InstructionType.APPLY_ACTIONS);
    		
    		//apply.addAction(createAction(negotiatedProtocolVersion, ActionType.PUSH_VLAN, EthernetType.VLAN));
    		//apply.addAction(createActionSetField(negotiatedProtocolVersion, OxmBasicFieldType.VLAN_VID, s.outvlan()));
    		apply.addAction(createAction(negotiatedProtocolVersion, ActionType.OUTPUT, Port.CONTROLLER, ActOutput.CONTROLLER_NO_BUFFER));
    		fm.addInstruction((Instruction)apply.toImmutable());
    	}
    	
	    MessageFuture future = controller.sendConfirmedFlowMod((OfmFlowMod)fm.toImmutable(), s.dpid());
	    try {
			future.await(REQUEST_TIMEOUT_MS);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    if (future.result().equals(MessageFuture.Result.SUCCESS)) {
	    	 long now = System.currentTimeMillis();
	    	 long duration = now - then;
	    	 log.info("FlowMod Latency to {} is {} ms", s.dpid(), duration);
	    	} else {
	    			log.warn("Failed to send FlowMod Request: {}", future.result());
	    	}
    	//Deprecated unreliable flowmod message
    	//controller.sendFlowMod((OfmFlowMod)fm.toImmutable(), s.dpid());
    	//auditLogService.post(user, source, activity, "Success");
}
    
    private Match createMatch(SwitchFlow s){
    	return createMatch(s.dpid(), s.srcip(), s.srcipmask(), s.dstip(), s.dstipmask(), 
    			s.protl(), PortNumber.valueOf(0), s.dstport());
    	
    	//deprecated code
    	/*
    	ProtocolVersion negotiatedProtocolVersion = controller.getDataPathInfo(s.dpid()).negotiated();
    	MutableMatch mm = MatchFactory.createMatch(negotiatedProtocolVersion)
    			.addField(createBasicField(negotiatedProtocolVersion, ETH_TYPE, EthernetType.IPv4))
    			.addField(createBasicField(negotiatedProtocolVersion, IPV4_SRC, s.srcip()))
    			.addField(createBasicField(negotiatedProtocolVersion, IPV4_DST, s.dstip()))
    			.addField(createBasicField(negotiatedProtocolVersion, IP_PROTO, s.protl()));
 
    	if (s.protl().equals(IpProtocol.TCP))
    		mm.addField(createBasicField(negotiatedProtocolVersion, TCP_DST, s.dstport()));
    	if (s.protl().equals(IpProtocol.UDP))
    		mm.addField(createBasicField(negotiatedProtocolVersion, UDP_DST, s.dstport()));
    	if (!(s.protl().equals(IpProtocol.TCP) || s.protl().equals(IpProtocol.UDP)))
    		throw new CreateException("IP Protocol is neither TCP nor UDP");
    	
    	return (Match) mm.toImmutable();
    	*/    	
    }

    @Override
    public SwitchFlow get(Id<SwitchFlow, UUID> id) {
        synchronized (store) {
            SwitchFlow s = store.get(id);
            if (s == null)
                throw new NotFoundException("SwitchFlow with id " + id + 
                                            " not found");
            return s;
        }
    }

    @Override
    public void delete(Id<SwitchFlow, UUID> id) throws OpenflowException{
    	SwitchFlow s;
        synchronized (store) {
            s = store.get(id);
            if (s == null)
                throw new NotFoundException("SwitchFlow with id " + id + 
                                            " not found");
        }
         removeByFlowMod(s);
        
         synchronized(cookie2id){
        	 for (Long cookie : cookie2id.keySet()){
        		 if (cookie2id.get(cookie).equals(id)){
        			 cookie2id.remove(cookie);
        			 break;
        		 }
        	 }
         }
         
        synchronized(store){
        		store.remove(id);
        	}
        
    }
    
    @Override
    public void install(Id<SwitchFlow, UUID> id, SwitchFlow s) throws OpenflowException{
    	long cookie = 0;
    	if (s.protl().equals(IpProtocol.TCP))
    		cookie = initialTcpFlowClass.baseCookie() | s.hashCode();
    	if (s.protl().equals(IpProtocol.UDP))
    		cookie = initialUdpFlowClass.baseCookie() | s.hashCode();
    	
    	synchronized(store){
    		store.put(id, s);
    	}
    	
    	synchronized(cookie2id){
    		cookie2id.put(Long.valueOf(cookie), id);
    	}
    	
    	try{
    		installByFlowMod(s);
    		auditLogService.post("Netlab", "VIPLink", "Install FlowMod", s.toString());
    		log.info("New flow installed:" + s.toString());
    	} catch(OpenflowException e){
    		synchronized(cookie2id){
    			cookie2id.remove(Long.valueOf(cookie));
    		}
    		synchronized(store){
				store.remove(s.getId());
				log.info("New flow installing unsuccessful:" + s.toString());
				throw e;
			}
    	}     	
    }
    
    
    @Override
    public Collection<SwitchFlow> getFlowByDpid(DataPathId dpid){
    	
    	boolean exist = false;
    	for (DataPathInfo di: controller.getAllDataPathInfo()){
    		if (di.dpid().equals(dpid)){
    			exist = true;
    		}
    	}
    	if (!exist){
    		throw new NotFoundException("Switch with DataPathId" + dpid.toString() + " not found");
    	}
    	
    	synchronized (store) {
    		Collection<SwitchFlow> flowSet = new HashSet<SwitchFlow>();
    		for (Id<SwitchFlow, UUID> flowId : store.keySet()){
    			if (store.get(flowId).dpid().equals(dpid)){
    				flowSet.add(store.get(flowId));
    			}
    		}
    		return flowSet;
    	}
    }
    
    @Override
    public void deleteFlowByDpid(DataPathId dpid) throws OpenflowException{
    	boolean exist = false;
    	for (DataPathInfo di: controller.getAllDataPathInfo()){
    		if (di.dpid().equals(dpid)){
    			exist = true;
    		}
    	}
    	if (!exist){
    		throw new NotFoundException("Switch with DataPathId" + dpid.toString() + " not found");
    	}
    	
    	Collection<Id<SwitchFlow, UUID>> flowSet = new HashSet<Id<SwitchFlow, UUID>> ();
    	synchronized(store){
    		for (Id<SwitchFlow, UUID> flowId : store.keySet()){
    			if (store.get(flowId).dpid().equals(dpid)){
    				flowSet.add(flowId);
    			}
    		}
    	}
    		
    	for(Id<SwitchFlow, UUID> flowIdToDelete: flowSet){
    		delete(flowIdToDelete);
    	}		
    	
    }
    
    @Override
    public void deleteFlowByName(String name) throws OpenflowException{
    	Id<SwitchFlow, UUID> flowIdtoDelete = null;
    	synchronized(store){
    		for (Id<SwitchFlow, UUID> flowId : store.keySet()){
    			if (store.get(flowId).name().equals(name)){
    				flowIdtoDelete = flowId;
    				break;
    			}
    		}
    	}
    	if (flowIdtoDelete == null){
			throw new NotFoundException("SwitchFlow with name " + name + " not found");
		}
    	else{
    		delete(flowIdtoDelete);
    	}
    }
    
    @Override
    public void deleteAll() throws OpenflowException{
    	HashSet<Id <SwitchFlow, UUID>> toDeleteSet = new HashSet<Id <SwitchFlow, UUID>>();
    	for (Id<SwitchFlow, UUID> flowId : store.keySet()){
    			toDeleteSet.add(flowId);
    	}
    	for (Id<SwitchFlow, UUID> flowID : toDeleteSet){
    		delete(flowID);
    	}
    }
    
    private void removeByFlowMod(SwitchFlow s) throws OpenflowException{
    	String name = s.name();
    	DataPathId dpid = s.dpid();
    	IpAddress srcip = s.srcip();
    	IpAddress srcipmask = s.srcipmask();
    	IpAddress dstip = s.dstip();
    	IpAddress dstipmask = s.dstipmask();
    	IpProtocol protl = s.protl();
    	PortNumber srcport = s.srcport();
    	PortNumber dstport = s.dstport();
    	VlanId invlan = s.invlan();
    	VlanId outvlan = s.outvlan();
    	BigPortNumber inport = s.inport();
    	BigPortNumber outport = s.outport();
    	
    	if (srcport.equals(PortNumber.valueOf(0)))
    		removeGeneralFlow(dpid, srcip, srcipmask, dstip, dstipmask, protl, dstport);
    			//throw new CreateException("Fail to remove general flow rule at switch");
    				
    	else{
    		removeForwardFlow (dpid, srcip, srcipmask, dstip, dstipmask, protl, srcport, dstport);
    		//remove backward flow
    		removeForwardFlow (dpid, dstip, dstipmask, srcip, srcipmask, protl, dstport, srcport);
    	}
    	//else {
    	//	throw new NotFoundException("The format of switchflow in controller is not correct");
    	//}
    }
    
    
    private void removeGeneralFlow(DataPathId dpid,IpAddress srcip, IpAddress srcipmask, 
    		IpAddress dstip, IpAddress dstipmask,  
    		IpProtocol protl, PortNumber dstport
    		) throws OpenflowException{
    	removeForwardFlow (dpid, srcip, srcipmask, dstip, dstipmask, protl, 
    			PortNumber.valueOf(0), dstport);
    }
    
    private void removeForwardFlow(DataPathId dpid,IpAddress srcip, IpAddress srcipmask, 
    		IpAddress dstip, IpAddress dstipmask,  
    		IpProtocol protl, PortNumber srcport, PortNumber dstport) throws OpenflowException{
    	// Hard coded timeout
    	long REQUEST_TIMEOUT_MS = 5000;
    	long then = System.currentTimeMillis();
    	
    	ProtocolVersion negotiatedProtocolVersion = controller.getDataPathInfo(dpid).negotiated();
    	OfmMutableFlowMod fm = (OfmMutableFlowMod)MessageFactory.create(negotiatedProtocolVersion, MessageType.FLOW_MOD,
				FlowModCommand.DELETE_STRICT);
    	if (srcport.equals(PortNumber.valueOf(0))){
	    	if (protl.equals(IpProtocol.TCP)){
	    		fm.cookie(initialTcpFlowClass.baseCookie()).priority(initialTcpFlowClass.priority());
	    	}
	    	if (protl.equals(IpProtocol.UDP)){
	    		fm.cookie(initialUdpFlowClass.baseCookie()).priority(initialUdpFlowClass.priority());
	    	}
    	}	else{
    		if (protl.equals(IpProtocol.TCP)){
	    		fm.cookie(refinedTcpFlowClass.baseCookie()).priority(refinedTcpFlowClass.priority());
    			//fm.priority(refinedPriority);
	    	}
	    	if (protl.equals(IpProtocol.UDP)){
	    		fm.cookie(refinedUdpFlowClass.baseCookie()).priority(refinedUdpFlowClass.priority());
	    		//fm.priority(refinedPriority);
	    	}
    	}
    	
    	fm.match(createMatch(dpid, srcip, srcipmask, dstip, dstipmask, protl, srcport, dstport));
    	
	    MessageFuture future = controller.sendConfirmedFlowMod((OfmFlowMod)fm.toImmutable(), dpid);
	    try {
			future.await(REQUEST_TIMEOUT_MS);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    if (future.result().equals(MessageFuture.Result.SUCCESS)) {
	    	long now = System.currentTimeMillis();
	    	long duration = now - then;
	    	log.info("FlowMod Latency to {} is {} ms", dpid, duration);
	    } else {
	    		log.warn("Failed to send FlowMod Request: {}", future.result());
	    }
 /*
    	catch(Exception e){
    		 log.warn(FLOWDELETEFAIL,e.toString());
    		 if (!dstport.equals(PortNumber.valueOf(0))){
    			 SwitchFlow s = new SwitchFlow(name, dpid, srcip, dstip, protl, srcport, dstport, inport, outport);
    			 questionable.put(s.getId(), s);
    		 }
    		 throw new CreateException(e.toString());
    	}
    	*/
    }
    
    
    @Override
    public Id<SwitchFlow, UUID> refineFlow(DataPathId dpid, MacAddress srcmac, IpAddress srcip, IpAddress dstip, 
			  IpProtocol protl, PortNumber srcport, PortNumber dstport, long cookie) throws OpenflowException{
    	
    	//SwitchFlow incomingFlow = new SwitchFlow("anonymous", dpid, srcip, dstip, protl, dstport, 
    	//		MacAddress.valueOf("00:00:00:00:00:00"), MacAddress.valueOf("00:00:00:00:00:00"), 
    	//		MacAddress.valueOf("00:00:00:00:00:00"),
    	//		MacAddress.valueOf("00:00:00:00:00:00"), VlanId.valueOf(0), VlanId.valueOf(0),
    	//		BigPortNumber.valueOf(0), BigPortNumber.valueOf(0),0);
    	Id<SwitchFlow, UUID> id =null;
    	SwitchFlow matchedFlow = null;
    	
    	synchronized(cookie2id){
    		if (cookie2id.containsKey(Long.valueOf(cookie))){
    			id = cookie2id.get(Long.valueOf(cookie));
    		}
    	}
    	
    	synchronized(store){
    		if (id != null){
    			matchedFlow = store.get(id);
    		}
    	}
    	
    	
    	//deprecated
//    	synchronized(store){
//    		for (Id<SwitchFlow, UUID> flowId: store.keySet()){
//    			
//    			if (store.get(flowId).equals(incomingFlow)){
//    				matchedFlow = store.get(flowId);
//    				//auditLogService.post("sdn", "SwitchFlowManager", "matched", matchedFlow.srcport().toString());
//    				if (matchedFlow.srcport().equals(PortNumber.valueOf(0))){
//    					id = flowId;
//    					matchedFlow = store.get(flowId);
//    					break;
//    				}
//    			}
//    		}
//    	}
    	
    	
    	if (id != null){
    		
    		//auditLogService.post("sdn", "SwitchFlowManager", "PacketListening", "id not null");
    		
    		matchedFlow.setInsrcmac(srcmac);
    		installForwardFlow(dpid,srcip,dstip,protl,srcport,dstport, matchedFlow.outsrcmac(), 
    				matchedFlow.outdstmac(),
    				matchedFlow.outvlan(),matchedFlow.outport(), matchedFlow.pushvlan());
    		
			installForwardFlow(dpid,dstip,srcip,protl,dstport,srcport, 
					matchedFlow.indstmac(), matchedFlow.insrcmac(), 
					matchedFlow.invlan(), matchedFlow.inport(), -matchedFlow.pushvlan());
    		
    		matchedFlow.setSrcport(srcport);
    		
    		
			removeGeneralFlow(dpid, srcip, matchedFlow.srcipmask(), dstip, matchedFlow.dstipmask(), 
					protl, dstport);
			
			matchedFlow.setSrcipmask(IpAddress.valueOf("255.255.255.255"));
    		matchedFlow.setDstipmask(IpAddress.valueOf("255.255.255.255"));
			
    		return id;
    	}
    	return null;
    }
    
    void installForwardFlow(DataPathId dpid, IpAddress srcip, IpAddress dstip, IpProtocol protl,
    		PortNumber srcport, PortNumber dstport, MacAddress outsrcmac, MacAddress outdstmac, 
    		VlanId outvlan, BigPortNumber outport, int pushvlan) throws OpenflowException{
    	ProtocolVersion negotiatedProtocolVersion = controller.getDataPathInfo(dpid).negotiated();
    	OfmMutableFlowMod fm = (OfmMutableFlowMod)MessageFactory.create(negotiatedProtocolVersion, 
    			MessageType.FLOW_MOD, FlowModCommand.ADD);
    	
    	IpAddress netmask = IpAddress.valueOf("255.255.255.255");
    	if (protl.equals(IpProtocol.TCP)){
    		fm.priority(refinedPriority)//.priority(refinedTcpFlowClass.priority())
    	.match(createMatch(dpid, srcip, netmask, dstip, netmask, protl, srcport, dstport));
    	}
    	
    	if (protl.equals(IpProtocol.UDP)){
    		fm.priority(refinedPriority)//.priority(refinedUdpFlowClass.priority())
        	.match(createMatch(dpid, srcip, netmask, dstip, netmask, protl, srcport, dstport));
    	}
    	
    	// For OpenFlow Version = 1.0
    	if (negotiatedProtocolVersion.equals(ProtocolVersion.V_1_0)){
    		fm.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD, createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.VLAN_VID, outvlan)));
    		fm.addAction(createAction(negotiatedProtocolVersion, ActionType.OUTPUT, outport));
    		if (pushvlan > 0){
    			fm.addAction(createAction(negotiatedProtocolVersion, ActionType.PUSH_VLAN, EthernetType.VLAN));
    		}	if (pushvlan < 0){
    			fm.addAction(createAction(negotiatedProtocolVersion, ActionType.POP_VLAN));
    		}
    		if (pushvlan >= 0){
    			fm.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD, 
        				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.VLAN_VID, outvlan)));
    		}
    		fm.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD, 
    				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.ETH_SRC, outsrcmac)));
    		fm.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD,
    				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.ETH_DST, outdstmac)));
    		fm.addAction(createAction(negotiatedProtocolVersion, ActionType.OUTPUT, outport));
    	}
    	
		// For OpenFlow Version >= 1.1
    	if (negotiatedProtocolVersion.ge(ProtocolVersion.V_1_1)){
    		InstrMutableAction apply = createMutableInstruction(negotiatedProtocolVersion, InstructionType.APPLY_ACTIONS);
    		if (pushvlan > 0){
    			apply.addAction(createAction(negotiatedProtocolVersion, ActionType.PUSH_VLAN, EthernetType.VLAN));
    		}	if (pushvlan < 0){
    			apply.addAction(createAction(negotiatedProtocolVersion, ActionType.POP_VLAN));
    		}
    		if (pushvlan >= 0){
    		apply.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD, 
    				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.VLAN_VID, outvlan)));
    		} 
    		apply.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD, 
    				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.ETH_SRC, outsrcmac)));
    		apply.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD,
    				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.ETH_DST, outdstmac)));
    		apply.addAction(createAction(negotiatedProtocolVersion, ActionType.OUTPUT, outport));
    		fm.addInstruction((Instruction)apply.toImmutable());
    	}
		
		/*
    	// Hard coded timeout
    	long REQUEST_TIMEOUT_MS = 5000;
    	long then = System.currentTimeMillis();
    	MessageFuture future = controller.sendConfirmedFlowMod((OfmFlowMod)fm.toImmutable(), dpid);
    	try {
			future.await(REQUEST_TIMEOUT_MS);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	if (future.result().equals(MessageFuture.Result.SUCCESS)) {
    		 long now = System.currentTimeMillis();
    		 long duration = now - then;
    		 auditLogService.post("sdn", "SwitchFlowManager", "duration", String.valueOf(duration));
    		 log.info("FlowMod Latency to {} is {} ms", dpid, duration);
    		} else {
    			 log.error("Failed to send FlowMod Request: {}", future.result());
    			 auditLogService.post("sdn", "SwitchFlowManager", "duration", "fail");
    		}
    	*/
    		//Deprecated
    		controller.sendFlowMod((OfmFlowMod)fm.toImmutable(), dpid);
    		//auditLogService.post(user, source, activity, "Success"); 	
    }
    
    Match createMatch(DataPathId dpid, IpAddress srcip, IpAddress srcipmask, IpAddress dstip, 
    		IpAddress dstipmask, IpProtocol protl, PortNumber srcport, PortNumber dstport){
    	ProtocolVersion negotiatedProtocolVersion = controller.getDataPathInfo(dpid).negotiated();
    	MutableMatch mm = MatchFactory.createMatch(negotiatedProtocolVersion)
    			.addField(createBasicField(negotiatedProtocolVersion, ETH_TYPE, EthernetType.IPv4))
    			.addField(createBasicField(negotiatedProtocolVersion, IPV4_SRC, srcip, srcipmask))
    			.addField(createBasicField(negotiatedProtocolVersion, IPV4_DST, dstip, dstipmask))
    			.addField(createBasicField(negotiatedProtocolVersion, IP_PROTO, protl));
 
    	if (protl.equals(IpProtocol.TCP)){
    		mm.addField(createBasicField(negotiatedProtocolVersion, TCP_DST, dstport));
    		if (!srcport.equals(PortNumber.valueOf(0)))
    		  mm.addField(createBasicField(negotiatedProtocolVersion, TCP_SRC, srcport));
    	}
    	if (protl.equals(IpProtocol.UDP)){
    		mm.addField(createBasicField(negotiatedProtocolVersion, UDP_DST, dstport));
    		if (srcport.equals(PortNumber.valueOf(0)))
    		  mm.addField(createBasicField(negotiatedProtocolVersion, UDP_SRC, srcport));
    	}
    	if (!(protl.equals(IpProtocol.TCP) || protl.equals(IpProtocol.UDP)))
    		throw new CreateException("IP Protocol is neither TCP nor UDP");
    	return (Match) mm.toImmutable();
    }
    
    @Override
    public void event(MessageContext context) {
    	//auditLogService.post("sdn", "SwitchFlowManager", "PacketListening", "Received Packet");
    	try{
    		log.info(context.toString());
    		//auditLogService.post("sdn", "SwitchFlowManager", "PacketListening", "Enter try block");
    		//log.info("Received packets");
    		
    		Ethernet eth = context.decodedPacket().get(ProtocolId.ETHERNET);
    		MacAddress srcmac = eth.srcAddr();
    		VlanId invlan = VlanId.valueOf(eth.vlanId());
    		
	    	Ip ip = context.decodedPacket().get(ProtocolId.IP);
	    	
	    	BigPortNumber inport = context.getPacketIn().getInPhyPort();
	    	
	    	DataPathId dpid = context.srcEvent().dpid();
	    	IpType ipType = ip.type();
	    	IpAddress srcip = ip.srcAddr();
	    	IpAddress dstip = ip.dstAddr();
	    	
	    	PortNumber srcport = null;
	    	PortNumber dstport = null;
	    	IpProtocol protl = null;
	    	
	    	if (ipType.equals(IpType.TCP)){
	    		
	    		Tcp tcp = context.decodedPacket().get(ProtocolId.TCP);
	    		protl = IpProtocol.TCP;
	    		srcport = PortNumber.valueOf(tcp.srcPort().getNumber());
	    		dstport = PortNumber.valueOf(tcp.dstPort().getNumber());
	    	}
	    	if (ipType.equals(IpType.UDP)){
	    	
	    		Udp udp = context.decodedPacket().get(ProtocolId.UDP);
	    		protl = IpProtocol.UDP;
	    		srcport = PortNumber.valueOf(udp.srcPort().getNumber());
	    		dstport = PortNumber.valueOf(udp.dstPort().getNumber());
	    	}
	    	
	    	
	    	if (protl != null){
	    		
	    		//auditLogService.post("sdn", "SwitchFlowManager", "Protocol", protl.toString());
	    		ProtocolVersion negotiatedProtocolVersion = controller.getDataPathInfo(dpid).negotiated();
	    		long cookie = context.getPacketIn().getCookie();
	    		Id<SwitchFlow, UUID> id = refineFlow(dpid, srcmac, srcip, dstip, protl, srcport, dstport, cookie);
	    		
	    
	    		if (id != null){
	    			
	    			PacketOut packetout = context.packetOut();
	    			BigPortNumber outport = null;
	    			VlanId outvlan = null;
	    			MacAddress outsrcmac = null;
	    			MacAddress outdstmac = null;
	    			int pushvlan = 0;
	    			synchronized (store){
	    				outport = store.get(id).outport();
	    				outvlan = store.get(id).outvlan();
	    				outsrcmac = store.get(id).outsrcmac();
	    				outdstmac = store.get(id).outdstmac();
	    				pushvlan = store.get(id).pushvlan();
	    			}
	    			if (pushvlan > 0){
	    				packetout.addAction(createAction(negotiatedProtocolVersion, ActionType.PUSH_VLAN, EthernetType.VLAN));
	    			}	if (pushvlan < 0){
	    				packetout.addAction(createAction(negotiatedProtocolVersion, ActionType.POP_VLAN));
	    			}
	    			if (pushvlan >= 0){
	    			packetout.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD,
	    					createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.VLAN_VID, outvlan)));
	    			}	
	    			packetout.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD, 
	        				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.ETH_SRC, outsrcmac)));
	        		packetout.addAction(createAction(negotiatedProtocolVersion, ActionType.SET_FIELD,
	        				createBasicField(negotiatedProtocolVersion, OxmBasicFieldType.ETH_DST, outdstmac)));
	    			packetout.addAction(createAction(negotiatedProtocolVersion, ActionType.OUTPUT, outport));
	    			//auditLogService.post("sdn", "SwitchFlowManager", "PacketListening", "sending packet");
	    			packetout.send();
	    		}
	    	}
	    	
	    		
	    	//reportOnDnsPacket(dns, context.srcEvent().dpid());
    	}
    	catch(Exception e){
    		//auditLogService.post("sdn", "SwitchFlowManager", "PacketListening Error", e.toString());
    		log.error(e.toString());
    	}
    	
    }
	
}

